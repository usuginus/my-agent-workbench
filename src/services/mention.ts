import { runCodexExec, type ExecError } from "../integrations/codex_client.js";
import { toSlackMarkdown } from "../integrations/slack_formatters.js";
import { type SlackContext } from "../integrations/slack_api.js";

function buildMentionPrompt(
  slackText: string,
  slackContext: SlackContext | null,
): string {
  return `
You are a helpful assistant responding in a Slack channel.
Reply naturally in Japanese. Be concise, friendly, and practical.
Do not mention internal steps (web search, doc lookup, logging) unless the user explicitly asks.

Local workspace context:
• This Slack agent is implemented in the \`my-agent-workbench\` repository.
• A \`my-agent-workbench/docs/\` directory exists in the same repository; use it for optional context and for writing summaries.
• The prompt is generated by code in \`my-agent-workbench/src/services/\`.

Guidelines:
• Ask 1 short clarifying question only when needed; otherwise answer directly.
• Use bullet points for lists; keep it short.
• URLs are allowed when helpful.
• When recommending restaurants/cafes/bars, include a Tabelog link for each place (if available).
• When surfacing technical articles or search results, include source links (original URLs) with the key points.

Performance rules (important):
• Default to the fastest path: answer immediately WITHOUT web search, WITHOUT docs search, and WITHOUT writing files.
• Only do extra work when it is clearly needed based on the user's message.
• Keep total context small: do not paste long excerpts; summarize in your own words.

Decision rules (gate the heavy work):
A) Web search: do it ONLY if the user explicitly asks for latest/current info or citations,
   or if the request obviously depends on time-sensitive external facts.
   Triggers (examples): "最新", "今日/今", "料金", "規約", "アップデート", "リリース", "比較", "おすすめ(店/製品)", "出典", "ソース", "URL", "リンク".

B) Docs search (\`my-agent-workbench/docs/\`): do it ONLY if the user explicitly refers to repo/docs/spec/past notes,
   or if the question is clearly about this agent's implementation/design.
   Triggers (examples): "docs", "README", "仕様", "設計", "このリポジトリ", "my-agent-workbench", "過去のメモ".
   Otherwise: DO NOT search docs.

C) Summary doc writing: do it ONLY if (1) the user asks to save/log/summarize,
   or (2) you performed A or B (web/docs) AND the answer contains non-trivial decisions worth recording.
   Otherwise: DO NOT write any doc.

Workflow (silent; do these in order, but only when enabled by the decision rules above):
1) (Optional) Web search if A is enabled. Use the minimum number of sources (1–3) and extract only key facts + URLs.
2) (Optional) Search under \`my-agent-workbench/docs/\` if B is enabled. Prefer the smallest relevant context.
3) Respond in Slack (this is always required). Keep it concise.
4) (Optional) If C is enabled, write/update a short summary doc at \`my-agent-workbench/docs/{theme}/{date}.md\`
   • {date}: YYYY-MM-DD (local time)
   • {theme}: short slug from the topic
   • If the file exists, append/update instead of duplicating.
   • Doc should include: question, brief answer, key links (if any), decisions/assumptions, TODO/next steps (if any).
   • IMPORTANT: keep the doc short; do not include large copied excerpts.

Output constraint:
• In Slack, do not paste the full doc; only the reply.
• Mention the doc path only if the user asks or it clearly helps.

User message:
${JSON.stringify(slackText)}

Slack context (JSON, if available):
${JSON.stringify(slackContext || null)}
  `.trim();
}

function formatMentionReply(text: string): string {
  let out = toSlackMarkdown(text);
  // Remove empty parentheses left behind by link stripping.
  out = out.replace(/\s*\(\s*\)\s*/g, " ");
  // Ensure numbered lists start on a new line.
  out = out.replace(/\s(\d+)\)/g, "\n$1)");
  // Ensure bullet points start on a new line.
  out = out.replace(/\s•/g, "\n•");
  // Collapse excessive newlines.
  out = out.replace(/\n{3,}/g, "\n\n");
  return out.trim();
}

function diagnoseFailure(err: ExecError) {
  const msg = `${err?.message ?? ""}\n${err?.stderr ?? ""}`.toLowerCase();
  if (msg.includes("enoent") || msg.includes("spawn codex")) {
    return "Codex CLI not found. Make sure `codex` is installed and on PATH.";
  }
  if (
    msg.includes("login") ||
    msg.includes("not logged in") ||
    msg.includes("auth")
  ) {
    return "Codex CLI authentication required. Run `codex login` and try again.";
  }
  if (msg.includes("timed out")) {
    return "Codex timed out. Shorten the request or increase the timeout.";
  }
  return "Codex execution failed. Check server stderr for details.";
}

export async function respondMention({
  slackText,
  workdir,
  slackContext,
}: {
  slackText: string;
  workdir: string;
  slackContext: SlackContext | null;
}) {
  const prompt = buildMentionPrompt(slackText, slackContext);
  try {
    const { stdout } = await runCodexExec({ prompt, cwd: workdir });
    const text = formatMentionReply((stdout || "").trim());
    if (!text) {
      throw new Error("Empty response from codex.");
    }
    return { ok: true, text };
  } catch (e) {
    const hint = diagnoseFailure(e as ExecError);
    console.error("respondMention failed", {
      error: (e as ExecError)?.message,
      stderr: (e as ExecError)?.stderr,
      stdout: (e as ExecError)?.stdout,
    });
    return {
      ok: false,
      text: `⚠️ 返信を生成できませんでした。原因: ${hint}`,
      debug: {
        error: (e as ExecError)?.message,
        stderr: (e as ExecError)?.stderr,
      },
    };
  }
}
